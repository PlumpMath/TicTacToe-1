{"name":"Tictactoe","tagline":"Production System for Tic Tac Toe.  By Ben Coyle, Ben Walsh Megan Ross and Mike Belanger","body":"### Tic Tac Toe Documentation\r\nby Mike Belanger, Ben Coyle, Ben Walsh and Megan Ross\r\n\r\n### Import the modules\r\n\r\nEnsure you have the files on your PYTHONPATH variable (or load them in IDLE).  From there, start a new python file and add:\r\n```python\r\nimport Environment\r\nimport Grid\r\nimport Agent\r\n```\r\n\r\n### Initialize Objects\r\n\r\nYou'll need at least one agent to populate the world.  To do this, create a new Agent, called **P1**, here, and give it the name **X**.\r\n```python\r\nP1 = Agent.Agent(\"X\")\r\n```\r\n\r\nFrom there, we'll need to create some chunk3s for our agent.  Chunk3s are the standard unit of information that populates a world.  Let's use the example of a chunk3 for representing a square on the board, which has a location:\r\n\r\n```python\r\ns1Loc= Chunk3 (P1,\"s1@\",\"s1\",\"has_loc\",(1,1))\r\n```\r\nThe above says \"make an object that belongs to player 1 (P1), whose ID is \"s1@\", name is \"s1\", and \"has_loc\" of the tuple (1,1) , ie the location of x=1, y = 1.  For any sort of game, a number of chunk3s are required.  Here is a list of other chunks to initialize:\r\n```python\r\ns1Loc= Chunk3 (P1,\"s1@\",\"s1\",\"has_loc\",(1,1))\r\ns2Loc= Chunk3 (P1,\"s1@\",\"s2\",\"has_loc\",(1,2))\r\ns3Loc= Chunk3 (P1,\"s1@\",\"s3\",\"has_loc\",(1,3))\r\ns4Loc= Chunk3 (P1,\"s1@\",\"s4\",\"has_loc\",(2,1))\r\ns5Loc= Chunk3 (P1,\"s1@\",\"s5\",\"has_loc\",(2,2))\r\ns6Loc= Chunk3 (P1,\"s1@\",\"s6\",\"has_loc\",(2,3))\r\ns7Loc= Chunk3 (P1,\"s1@\",\"s7\",\"has_loc\",(3,1))\r\ns8Loc= Chunk3 (P1,\"s1@\",\"s8\",\"has_loc\",(3,2))\r\ns9Loc= Chunk3 (P1,\"s1@\",\"s9\",\"has_loc\",(3,3))\r\ns1S= Chunk3 (P1,\"s1S\",\"s1\",\"has_$\",\"_\")\r\ns2S= Chunk3 (P1,\"s2S\",\"s2\",\"has_$\",\"_\")\r\ns3S= Chunk3 (P1,\"s3S\",\"s3\",\"has_$\",\"_\")\r\ns4S= Chunk3 (P1,\"s4S\",\"s4\",\"has_$\",\"_\")\r\ns5S= Chunk3 (P1,\"s5S\",\"s5\",\"has_$\",\"_\")\r\ns6S= Chunk3 (P1,\"s6S\",\"s6\",\"has_$\",\"_\")\r\ns7S= Chunk3 (P1,\"s7S\",\"s7\",\"has_$\",\"_\")\r\ns8S= Chunk3 (P1,\"s8S\",\"s8\",\"has_$\",\"_\")\r\ns9S= Chunk3 (P1,\"s9S\",\"s9\",\"has_$\",\"_\")\r\ns1R= Chunk3 (P1,\"s1R\",\"s1\",\"has_type\",\"corner\")\r\ns2R= Chunk3 (P1,\"s2R\",\"s2\",\"has_type\",\"edge\")\r\ns3R= Chunk3 (P1,\"s3R\",\"s3\",\"has_type\",\"corner\")\r\ns4R= Chunk3 (P1,\"s4R\",\"s4\",\"has_type\",\"edge\")\r\ns5R= Chunk3 (P1,\"s5R\",\"s5\",\"has_type\",\"center\")\r\ns6R= Chunk3 (P1,\"s6R\",\"s6\",\"has_type\",\"edge\")\r\ns7R= Chunk3 (P1,\"s7R\",\"s7\",\"has_type\",\"corner\")\r\ns8R= Chunk3 (P1,\"s8R\",\"s8\",\"has_type\",\"edge\")\r\nR123= Chunk3 (P1,\"R123\",[\"s1\",\"s2\",\"s3\"],\"is_a\",\"Row\")\r\nR456= Chunk3 (P1,\"R456\",[\"s4\",\"s5\",\"s6\"],\"is_a\",\"Row\")\r\nR789= Chunk3 (P1,\"R789\",[\"s7\",\"s8\",\"s9\"],\"is_a\",\"Row\")\r\nC147= Chunk3 (P1,\"C147\",[\"s1\",\"s4\",\"s7\"],\"is_a\",\"Column\")\r\nC258= Chunk3 (P1,\"C258\",[\"s2\",\"s5\",\"s8\"],\"is_a\",\"Column\")\r\nC369= Chunk3 (P1,\"C369\",[\"s3\",\"s6\",\"s9\"],\"is_a\",\"Column\")\r\nD159= Chunk3 (P1,\"D159\",[\"s1\",\"s5\",\"s9\"],\"is_a\",\"Diagonal\")\r\nD357= Chunk3 (P1,\"D357\",[\"s3\",\"s5\",\"s7\"],\"is_a\",\"Diagonal\")\r\n```\r\nNext, we need an environment for everything to live in. We should pass P1 (agent \"X\") into this environment too.  We've named the environment here \"TTT\".\r\n\r\n```python\r\nTTT = Environment.Environment(P1)\r\n```\r\n\r\n###Create chunks representing the board, add them to chunk display list.\r\nWhile the above could be considered P1's understanding of a board, we need to create the world's actual board chunks as well.  The below code initializes these world chunks. \r\n\r\n```python\r\ns1 = Chunk3(TTT,'s1', '_', 1, (1, 1), 0.0); TTT.chunk_display.append(s1)\r\ns2 = Chunk3(TTT,'s2', '_', 2, (2, 1), 0.0); TTT.chunk_display.append(s2)\r\ns3 = Chunk3(TTT,'s3', '_', 3, (3, 1), 0.0); TTT.chunk_display.append(s3)\r\ns4 = Chunk3(TTT,'s4', '_', 4, (1, 2), 0.0); TTT.chunk_display.append(s4)\r\ns5 = Chunk3(TTT,'s5', '_', 5, (2, 2), 0.0); TTT.chunk_display.append(s5)\r\ns6 = Chunk3(TTT,'s6', '_', 6, (3, 2), 0.0); TTT.chunk_display.append(s6)\r\ns7 = Chunk3(TTT,'s7', '_', 7, (1, 3), 0.0); TTT.chunk_display.append(s7)\r\ns8 = Chunk3(TTT,'s8', '_', 8, (2, 3), 0.0); TTT.chunk_display.append(s8)\r\ns9 = Chunk3(TTT,'s9', '_', 9, (3, 3), 0.0); TTT.chunk_display.append(s9)\r\n```\r\nLet's check out s1.  s1 requires an environment to live in(```TTT```), an ID (```'s1'```), what it has in it (```'_'```), an ordinal board position (```1```), a pair of coordinates (```(1, 1)```), and an activation (```(0.0)```).   **Note:** the ```TTT.chunk_display.append(s1, s2, etc)``` at the end of each line is optional, and only if you want to draw the results on a grid, for a later step.\r\n\r\n**Optional**\r\nIf you would like to display your results in a grid easily, we can do an additional step to enable this.\r\n```python\r\nTTT.grid = Grid.Grid(3, 3, raw_chunks = TTT.chunk_display[:], display_attr = 'thingX')\r\n```\r\nThe above asks the environment TTT's grid attribute to become a grid (by default its None), make it 3 rows by 3 columns, feed a copy of its chunk_display into its raw_chunks parameter.  Finally, we ask that it fills the grid with the raw_chunks' 'thingX' attribute (under display_attr).\r\n\r\n###Some aliases for easier production definitions.\r\nNext, we'll add some variable definitions to easily command our productions.  These variables are essentially standins for some strings.  Those strings are actually just the string version of commands that the production system executes.\r\n\r\n```python\r\ngoal='self.agent.goal'\r\nsubgoal='self.agent.subgoal'\r\nfocus='self.agent.focus'\r\nis_string = 'isinstance(self.agent.focus[-1:],str)'\r\nmodify = 'self.e.write('\r\nclear_focus = 'focus=[]'\r\n```\r\n\r\nNow we'll actually invoke the productions.  Each production is a production object, which contains a single condition >> action pair.  Let's look at the first one we'll add, p1_start:\r\n```python\r\np1_start = Production(P1,TTT,[goal+'==\"start\"'], [goal+'=\"assess\"'])\r\n```\r\nThis new production instance needs an agent (``P1``), and an environment (``TTT``).  Next, we'll feed it its necessary conditions to fire (``[goal+'==\"start\"']``), and its corresponding action (``[goal+'=\"assess\"']``).  Remember that ``goal+`` is the string meaning ``'self.agent.goal'``, and gets added in front of the strings proceeding it.  Also note that within each list, multiple items can be added as well.  This means that a production can have more than one necessary condition to be true, and more than one action to fire.  Here's some more productions:\r\n\r\n```python\r\np1_start = Production(P1,TTT,[goal+'==\"start\"'], [goal+'=\"assess\"'])\r\np1_qualify= Production(P1,TTT,[goal+'==\"assess\"',subgoal+'==\"\"'], [subgoal+'=\"find blank\"'])\r\n\r\np1_assess = Production(P1,TTT,[goal+'==\"assess\"',subgoal+'==\"find blank\"'],\r\n            [focus+'=self.agent.returnMissing(None,None,\"_\",\"all\")',subgoal+'=\"choose\"'])\r\n\r\np1_choose = Production(P1,TTT,[goal+'==\"assess\"',subgoal+'==\"choose\"'],\r\n                       [focus+'=(self.agent.assess('+focus+'))',goal+'=\"fill blank\"'])\r\n\r\np1_fillBlank = Production(P1,TTT, [goal+'==\"fill blank\"'], [ modify + focus + ',self.agent)', clear_focus,\r\n                    subgoal+'=\"\"','self.agent.CheckWinLoss()', goal + '=\"wait\"'])\r\n\r\np1_wait = Production(P1,TTT,[goal+'==\"wait\"', is_string], ['self.agent.goal=\"assess\"'])\r\n```\r\nFinally, we can start the simulation by invoking the startGame() function.\r\n\r\n###Now, start production.  Enjoy!\r\n```python\r\nTTT.startGame()\r\n```\r\n\r\n#### Data System\r\n\r\nThe tic-tac-toe production system relies heavily on the Chunk system.  This means that all meaningful information that both the agents and the environment understand are represented in chunks.  Here's a rough overview of how the chunk system implements Tic-Tac-Toe:\r\n\r\n![/wiki/](https://github.com/mikebelanger/TicTacToe/raw/master/doc/img/DataSystem.jpg)\r\n\r\nThe above shows how chunks create meaning for both the Tic Tac Toe board and the agent's understanding of the board.  This means that the Agent has access to the actual board units as chunks, as well as their own knowledge.  Their own chunks can be considered analogous to long-term memory.\r\n\r\n#### Productions\r\n\r\nEach time the environment is started, it invokes each agent (currently limited to 2) to go through their respective production lists, and determine which production is true.  If so, it executes (fires).\r\n\r\n![/wiki/](https://github.com/mikebelanger/TicTacToe/raw/master/doc/img/AgentProduction.png)\r\n\r\nOnce the agent has exhausted all its possible firings, the environment invokes the second agent to do the same.  In the case of tic-tac-toe, Environment will continue to alternate between agents until the board is full, or an agent wins.  Whichever comes first.\r\n\r\n\r\n#### Production Syntax\r\n\r\nThe tic-tac-toe production system works on the basis of productions.  Each production contains a necessary condition, consequent action pair, an agent to fire them, and an environment for it to exist in.  These production instances look like this:\r\n```python\r\nsome_production = Production(some_agent, some_environment, ['A'], ['B'])\r\n```\r\nHere, the example states that some_agent is invoked with condition 'A', they will do 'B'.  Note that the beauty of this system is you can specify (theoretically) unlimited conditions and actions.  For instance:\r\n```python\r\nanother_production = Production(some_agent, some_environment, ['A', 1, 'C'], ['D'])\r\n```\r\nThis says \"if some_agent encounters 'A', **and** 'B' **and** 1, then fire 'D'.\"\r\n\r\nConversely, this means that one antecedent condition can trigger multiple actions:\r\n```python\r\nanother_production2 = Production(some_agent, some_environment, ['A'], ['D', 'E', 'F'])\r\n```\r\n\r\nHere its stated that \"if some_agent encounters 'A', fire 'D', 'E', and 'F'.\".  So this production system is fairly flexible.  **Note:**the above examples are meant to be simple, and realistically, something more complex than letters will be required.  This is because the strings within those lists are actually python commands.  That said, its as easy as assigning a complex string like ```A = 'self.agent.goal == \"start\"'```, and then pass ```A``` into the conditions list.\r\n\r\n\r\n#### Variables in the Productions\r\n\r\nThe production system is ultimately evaluating the strings of python system commands.  However, this does not mean users have to familiarize themselves with these commands.  The TicTacToe.py example provides variables which stand in for these rather esoteric strings.\r\n\r\nTo use these variables, we should be familiar with how they're manipulated first.  It is important to understand that combining a string means adding a + between any statements:\r\n```python\r\nanother_production3 = Production(some_agent, some_environment, ['A' + 'B'], ['D', 'E', 'F'])\r\n```\r\nMeans that \"If the system encounters 'AB', and do 'D', 'E', and 'F'\".  \r\n\r\nOf course, there needs to be syntax for more complex expressions.  So the TicTacToe.py adheres to some other conventions:\r\n```python\r\nA = 'B'\r\nD = ''\r\nanother_production4 = Production(some_agent, some_environment, [A + IS + 'B'], [D BECOMES 'E'])\r\n```\r\nThis means that 'if the variable A (now a variable representing a string) **has the contents of** 'B', then variable D **becomes** 'E''.\r\n\r\n#### Format\r\n\r\nAnything ending with a .format in the productions is essentially a function. In this example, someFunction is getting the variables A and D passed into it.  **Note** by convention, the amount of variables a function takes should be written at the end of the variable name.  Here, someFunction2 means that it takes two variables.\r\n\r\n```python\r\nA = 'B'\r\nD = '_'\r\nsomeFunction2 = 'self.e.someFunction({0}, {1})'\r\n\r\nanother_production5 = Production(some_agent, some_environment, [ someFunction2.format(A, D) + IS + 'B_' ], \r\n\r\n[D BECOMES 'E'])\r\n```\r\nThe above statement says 'if the result of someFunction2 using A, and D is 'B_', then D becomes 'E'.'  Note that one does not need to assign variables to test the result of something.  The above can test what happens to A, D, and evaluate it on one line.\r\n\r\nWhile most of your functions should be variabalized (see [[SuggestedVariables]]) its good to understand what these various functions do.  Here are the key functions, organized by module.\r\n\r\n####Agent Module\r\n```python\r\nSortProductions(self)\r\n```\r\nWhile the user will likely never work directly with this function, it should be noted how crucial it is for the system to run.  SortProductions sorts through all of the agent's potential productions for truth values, and executes the action which is true.\r\n\r\n```python\r\nrandom_choose(self, object_list):\r\n```\r\nrandom_choose takes in a list of objects and returns 1 random entry.  While this is not ideal cognitively, this is often useful for testing something.\r\n\r\n```python\r\nutility(self,anID):\r\n```\r\nWhile this is specific to Tic-Tac-Toe, its algorithm is likely re-purposable to other things.  This takes the ID of a Chunk and returns its 'utility' value in integer form.  A 'utility' value can be thought of as an objective rating of overall benefit of a certain thing.\r\n\r\n```python\r\nassess(self,aList):\r\n```\r\n\r\nLike utility, assess is somewhat specific to Tic-Tac-Toe.  However, with some modifications it could be re-purposed for larger playing spaces.  Assess takes in a list of strings, and decides which space is the most optimal and returns one of them.\r\n\r\n```python\r\nsearchByAttribute(self, chunkList, attribute, attributeContains):\r\n```\r\n\r\nThis function takes in a list of objects (typically chunks, here as **chunkList**) and searches through the object's specified attribute (**attribute**) for anything matching **attributeContains**, and returns a list of the matching objects.\r\n\r\n\r\n```python\r\nstripChunk(self, chunkList, attribute):\r\n```\r\nThis takes in a list of chunks, and returns a list of a string version of the objects' specified *attribute*.\r\n\r\n```python\r\nsearch(self, chunkList, *args)\r\n```\r\n\r\nThis nifty utility takes in a list of objects (typically chunks) and returns all chunks who have attributes contents matching **all** of the specified arguments **args**.\r\n\r\n####Production Module\r\n\r\n```python\r\nfire(self):\r\n```\r\nWhile this particular method may seem self-explanatory, it should be mentioned that it can be used to fire individual productions.  This is useful for debugging purposes.  ie)\r\n\r\n```python\r\nProductionInstance.fire()\r\n```\r\n\r\n```python\r\naskLS(self)\r\n```\r\n\r\nWhile the user will likely never interact with this function, it is important to recognize its significance.  This function takes in each 'left side' item of the production, and returns it if the LS is true.\r\n\r\n####Environment Module\r\n\r\nThe environment module can take manage two agents, and is linked to the productions if specified.  There are only really a few functions here, but they are important:\r\n\r\n```python\r\nwrite(self,c, Agent):\r\n```\r\nThe write function allows agents to change aspects of their environment.  It takes in c, which is unique ID of the target chunk being changed, and Agent, which refers to the Agent's name.  If the environment can find an object matching c, it will replace its .ID attribute with the Agent's .ID attribute.\r\n\r\n```python\r\nstartGame(self, n = 50):\r\n```\r\n\r\nThis initiates the environment update loop, which invokes each Agent's SortProductions() methods, until the board is full, or its counter passes **n**, which defaults to 50.\r\n\r\n\r\n####Chunks Module\r\n\r\nThe chunk system is an integral part of data for the Tic Tac Toe production system.  Chunks are classes meant to store units of string-based information, with relational data as well.  Within the Chunks module exist three different kinds of chunks : Chunk, and its derivatives, Chunk1, Chunk2, and Chunk3.\r\n\r\nChunks\r\nThese represent a single unit of information.  These should be used for any simple information, such as a number.\r\n```python\r\nc = Chunk(ID, activation=0)\r\n```\r\nID refers to some unique identifier of the chunk system, and activation is an integer meant to capture how activated something is.  It should be noted that this has one method, which is descendents also share:\r\n\r\n```python\r\naddToActivation(self, addend)\r\n```\r\nThis allows for chunks to be activated in various ways.  Perhaps to show how 'active' a memory is.  It always keeps the number between 0 and 1.\r\n\r\n```python\r\nc = Chunk1(agent, ID, thingX=0.0, activation=0.0)\r\n```\r\nChunk1 (inherits from Chunk)\r\nThese are bits of memory with only one part.  They require an ID, a thingX, and an activation.  You may notice that it takes an **agent** parameter, which can effectively link agents to this unit of information.\r\n\r\n```python\r\nc = Chunk2( ID, thingX,thingY, activation=0.0)\r\n```\r\nChunk2 (inherits from Chunk)\r\nThese are similar to Chunk1s, but they have an additional variable, a 'thingY'.\r\n\r\n```python\r\nc = Chunk3(agent, ID, thingX, relation, thingY, activation=0.0)\r\n```\r\nChunk3 (inherits from Chunk)\r\nThese have a variety of attributes, which can be used for virtually anything.  However, the last attribute should remain activation, for simplicity's sake.\r\n\r\n###Suggested Variables\r\n\r\nThe tic-tac-toe examples comes with abundant examples of variables, which can greatly ease the definition of productions.\r\n\r\nOf course, the variables may be renamed, but this is the suggested naming convention:\r\n```python\r\n\r\nBECOMES = '='\r\nIS = '=='\r\nADDED2 = '{0}.append({1})'\r\nnothing = '\"\"'\r\nempty = '[]'\r\nzero = '0'\r\none = '1'\r\n\r\n\r\ngoal='self.agent.goal'\r\nsubgoal='self.agent.subgoal'\r\nfocus='self.agent.focus'\r\nview = 'self.agent.view'\r\nis_string = 'isinstance(self.agent.focus[-1:],str)'\r\ncheck_rows = '\"check rows\"'\r\nsubfocus = 'self.agent.sub_focus'\r\n\r\n\r\nmove = 'self.agent.effector'\r\n\r\nstart = '\"start\"'\r\nassess = '\"assess\"'\r\nwait = '\"wait\"'\r\n\r\ncheck_rows = '\"check rows\"'\r\nfind_blank = '\"find blank\"'\r\n\r\nsearch2 = 'self.agent.search({0}, {1})'\r\nsearch3 = 'self.agent.search({0}, {1}, {2})'\r\nsearch4 = 'self.agent.search({0}, {1}, {2}, {3})'\r\ntarget1 = 'self.agent.returnID({0})'\r\nmodify2 = 'self.e.write({0}, {1})'\r\nrandom1 = 'self.agent.random_choose({0})'\r\nmore_than_zero = 'len({0}) > 0'\r\nassess1 = 'self.agent.assess({0})'\r\nstrip2 = 'self.agent.stripChunk({0},{1})'\r\n\r\n\r\nquantify1 = 'len({0})'\r\nsay1    = 'print {0}' \r\nworld = 'self.e.memory'\r\nmemory = 'self.agent.memory'\r\n\r\nagent1 = 'self.e.Agent1'\r\nagent2 = 'self.e.Agent2'\r\nagent1goal = 'self.e.Agent1.goal'\r\nagent2goal = 'self.e.Agent2.goal'\r\n\r\n\r\nend = 'self.e.running = False'\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}